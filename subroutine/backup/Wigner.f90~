function w3jsym(J1,J2,J3,M1,M2)
integer(4),parameter :: NDIM=100
integer(4) :: IER3
real(8) :: M2MIN, M2MAX, THRCOF(NDIM),J1,J2,J3,M1,M2,w3jsym

THRCOF=0.0d0
call DRC3JM(J1,J2,J3,M1,M2MIN, M2MAX, THRCOF, NDIM, IER3)
if(IER3.eq.2) then
   THRCOF=0.0d0
   write(6,*) "IER3=",IER3
end if
w3jsym=THRCOF(int(M2-M2MIN)+1)

return
end function w3jsym



function w6jsym(J1,J2,J3,J4,J5,J6)
integer(4),parameter :: NDIM=100
integer(4) :: IER3
real(8) :: L1MIN, L1MAX, SIXCOF(NDIM),J1,J2,J3,J4,J5,J6,w6jsym

SIXCOF=0.0d0
call DRC6J(J2, J3, J4, J5, J6, L1MIN, L1MAX, SIXCOF, NDIM, IER6)
if(IER6.eq.2) SIXCOF=0.0d0
w6jsym=SIXCOF(int(J1-L1MIN)+1)

return
end function w6jsym


!
!  slatec_3j_f90.f90
!  slatec.git
!
!  This file contains an extract of the huge Slatec library that allows the user
!  to compute just the 3J and 6J Wigner Symbols, which are closely related to the
!  Clebsch-Gordan and Racah W-coefficients, respectively.
!
!  This is part the Fortran90 version of the SLATEC library, which was kindly
!  ported from the Fortran77 original by John Burkardt, which I thank. The F90
!  port can be found at http://people.sc.fsu.edu/~jburkardt/f_src/slatec/slatec.html,
!  while the original F77 version is hosted on Netlib:
!  http://www.netlib.org/slatec/index.html

subroutine DRC3JM (L1, L2, L3, M1, M2MIN, M2MAX, THRCOF, NDIM, &
IER)
!
!! DRC3JM evaluates the 3j symbol g(M2) for all allowed values of M2.
!
!***PURPOSE  Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
!                                           (M1 M2 -M1-M2)
!            for all allowed values of M2, the other parameters
!            being held fixed.
!
!***LIBRARY   SLATEC
!***CATEGORY  C19
!***TYPE      DOUBLE PRECISION (RC3JM-S, DRC3JM-D)
!***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
!             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
!             WIGNER COEFFICIENTS
!***AUTHOR  Gordon, R. G., Harvard University
!           Schulten, K., Max Planck Institute
!***DESCRIPTION
!
! *Usage:
!
!        DOUBLE PRECISION L1, L2, L3, M1, M2MIN, M2MAX, THRCOF(NDIM)
!        INTEGER NDIM, IER
!
!        call DRC3JM (L1, L2, L3, M1, M2MIN, M2MAX, THRCOF, NDIM, IER)
!
! *Arguments:
!
!     L1 :IN      Parameter in 3j symbol.
!
!     L2 :IN      Parameter in 3j symbol.
!
!     L3 :IN      Parameter in 3j symbol.
!
!     M1 :IN      Parameter in 3j symbol.
!
!     M2MIN :OUT  Smallest allowable M2 in 3j symbol.
!
!     M2MAX :OUT  Largest allowable M2 in 3j symbol.
!
!     THRCOF :OUT Set of 3j coefficients generated by evaluating the
!                 3j symbol for all allowed values of M2.  THRCOF(I)
!                 will contain g(M2MIN+I-1), I=1,2,...,M2MAX-M2MIN+1.
!
!     NDIM :IN    Declared length of THRCOF in calling program.
!
!     IER :OUT    Error flag.
!                 IER=0 No errors.
!                 IER=1 Either L1 < ABS(M1) or L1+ABS(M1) non-integer.
!                 IER=2 ABS(L1-L2) <= L3 <= L1+L2 not satisfied.
!                 IER=3 L1+L2+L3 not an integer.
!                 IER=4 M2MAX-M2MIN not an integer.
!                 IER=5 M2MAX less than M2MIN.
!                 IER=6 NDIM less than M2MAX-M2MIN+1.
!
! *Description:
!
!     Although conventionally the parameters of the vector addition
!  coefficients satisfy certain restrictions, such as being integers
!  or integers plus 1/2, the restrictions imposed on input to this
!  subroutine are somewhat weaker. See, for example, Section 27.9 of
!  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
!  The restrictions imposed by this subroutine are
!       1. L1 >= ABS(M1) and L1+ABS(M1) must be an integer;
!       2. ABS(L1-L2) <= L3 <= L1+L2;
!       3. L1+L2+L3 must be an integer;
!       4. M2MAX-M2MIN must be an integer, where
!          M2MAX=MIN(L2,L3-M1) and M2MIN=MAX(-L2,-L3-M1).
!  If the conventional restrictions are satisfied, then these
!  restrictions are met.
!
!     The user should be cautious in using input parameters that do
!  not satisfy the conventional restrictions. For example, the
!  the subroutine produces values of
!       g(M2) = (0.751.50   1.75  )
!               (0.25  M2  -0.25-M2)
!  for M2=-1.5,-0.5,0.5,1.5 but none of the symmetry properties of the
!  3j symbol, set forth on page 1056 of Messiah, is satisfied.
!
!     The subroutine generates g(M2MIN), g(M2MIN+1), ..., g(M2MAX)
!  where M2MIN and M2MAX are defined above. The sequence g(M2) is
!  generated by a three-term recurrence algorithm with scaling to
!  control overflow. Both backward and forward recurrence are used to
!  maintain numerical stability. The two recurrence sequences are
!  matched at an interior point and are normalized from the unitary
!  property of 3j coefficients and Wigner's phase convention.
!
!    The algorithm is suited to applications in which large quantum
!  numbers arise, such as in molecular dynamics.
!
!***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
!                  of Mathematical Functions with Formulas, Graphs
!                  and Mathematical Tables, NBS Applied Mathematics
!                  Series 55, June 1964 and subsequent printings.
!               2. Messiah, Albert., Quantum Mechanics, Volume II,
!                  North-Holland Publishing Company, 1963.
!               3. Schulten, Klaus and Gordon, Roy G., Exact recursive
!                  evaluation of 3j and 6j coefficients for quantum-
!                  mechanical coupling of angular momenta, J Math
!                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
!               4. Schulten, Klaus and Gordon, Roy G., Semiclassical
!                  approximations to 3j and 6j coefficients for
!                  quantum-mechanical coupling of angular momenta,
!                  J Math Phys, v 16, no. 10, October 1975,
!                  pp. 1971-1988.
!               5. Schulten, Klaus and Gordon, Roy G., Recursive
!                  evaluation of 3j and 6j coefficients, Computer
!                  Phys Comm, v 11, 1976, pp. 269-278.
!***ROUTINES CALLED  D1MACH, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   750101  DATE WRITTEN
!   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
!           HUGE and TINY revised to depend on D1MACH.
!   891229  Prologue description rewritten; other prologue sections
!           revised; MMATCH (location of match point for recurrences)
!           removed from argument list; argument IER changed to serve
!           only as an error flag (previously, in cases without error,
!           it returned the number of scalings); number of error codes
!           increased to provide more precise error information;
!           program comments revised; SLATEC error handler calls
!           introduced to enable printing of error messages to meet
!           SLATEC standards. These changes were done by D. W. Lozier,
!           M. A. McClain and J. M. Smith of the National Institute
!           of Standards and Technology, formerly NBS.
!   910415  Mixed type expressions eliminated; variable C1 initialized;
!           description of THRCOF expanded. These changes were done by
!           D. W. Lozier.
!***END PROLOGUE  DRC3JM
!
INTEGER NDIM, IER
DOUBLE PRECISION L1, L2, L3, M1, M2MIN, M2MAX, THRCOF(NDIM)
!
INTEGER I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM, &
NSTEP2
DOUBLE PRECISION A1, A1S, C1, C1OLD, C2, CNORM, D1MACH, DV, EPS, &
HUGE, M2, M3, NEWFAC, OLDFAC, ONE, RATIO, SIGN1, &
SIGN2, SRHUGE, SRTINY, SUM1, SUM2, SUMBAC, &
SUMFOR, SUMUNI, THRESH, TINY, TWO, X, X1, X2, X3, &
Y, Y1, Y2, Y3, ZERO
!
DATA  ZERO,EPS,ONE,TWO /0.0D0,0.01D0,1.0D0,2.0D0/

!! Debug
! print*, "PARAMETERS FOR FUNCTION DRC3JM"
! print*, "L1", L1
! print*, "L2", L2
! print*, "L3", L3
! print*, "M1", M1
! print*, "NDIM", NDIM

!***FIRST EXECUTABLE STATEMENT  DRC3JM
IER=0
!  HUGE is the square root of one twentieth of the largest floating
!  point number, approximately.
HUGE = SQRT(D1MACH(2)/20.0D0)
SRHUGE = SQRT(HUGE)
TINY = 1.0D0/HUGE
SRTINY = 1.0D0/SRHUGE
!
!
!  Limits for M2
M2MIN = MAX(-L2,-L3-M1)
M2MAX = MIN(L2,L3-M1)
!! Debug
! print*, "M2MIN", M2MIN
! print*, "M2MAX", M2MAX
!
!
!
!  Check error conditions 1, 2, and 3.
if ( (L1-ABS(M1)+EPS < ZERO).OR. &
(MOD(L1+ABS(M1)+EPS,ONE) >= EPS+EPS))THEN
IER=1
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JM','L1-ABS(M1) less than zero or '// &
!    'L1+ABS(M1) not integer.',IER,1)
return
ELSEIF((L1+L2-L3 < -EPS).OR.(L1-L2+L3 < -EPS).OR. &
(-L1+L2+L3 < -EPS))THEN
IER=2
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JM','L1, L2, L3 do not satisfy '// &
!    'triangular condition.',IER,1)
return
ELSEIF(MOD(L1+L2+L3+EPS,ONE) >= EPS+EPS)THEN
IER=3
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JM','L1+L2+L3 not integer.',IER,1)
return
end if



!  Check error condition 4.
if ( MOD(M2MAX-M2MIN+EPS,ONE) >= EPS+EPS)THEN
IER=4
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JM','M2MAX-M2MIN not integer.',IER,1)
return
end if
if ( M2MIN < M2MAX-EPS)   go to 20
if ( M2MIN < M2MAX+EPS)   go to 10
!
!  Check error condition 5.
IER=5
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JM','M2MIN greater than M2MAX.',IER,1)
return
!
!
!  This is reached in case that M2 and M3 can take only one value.
10 CONTINUE
!     MSCALE = 0
THRCOF(1) = (-ONE) ** INT(ABS(L2-L3-M1)+EPS) / &
SQRT(L1+L2+L3+ONE)
return
!
!  This is reached in case that M1 and M2 take more than one value.
20 CONTINUE
!     MSCALE = 0
NFIN = INT(M2MAX-M2MIN+ONE+EPS)
! print*, "NDIM =", NDIM, "NFIN = ", NFIN
! print*, "M2MAX = ", M2MAX, "M2MIN = ", M2MIN, "ONE = ", ONE, "EPS = ", EPS, "M2MAX-M2MIN+ONE+EPS", M2MAX-M2MIN+ONE+EPS
! This is an ARITMETIC IF:  IF (expression) negative,zero,positive
if ( NDIM-NFIN)   21, 23, 23
!
!  Check error condition 6.
21 IER = 6
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JM','Dimension of result array for '// &
!             '3j coefficients too small.',IER,1)
return
!
!
!
!  Start of forward recursion from M2 = M2MIN
!
23 M2 = M2MIN
THRCOF(1) = SRTINY
NEWFAC = 0.0D0
C1 = 0.0D0
SUM1 = TINY
!
!
LSTEP = 1
30 LSTEP = LSTEP + 1
M2 = M2 + ONE
M3 = - M1 - M2
!
!
OLDFAC = NEWFAC
A1 = (L2-M2+ONE) * (L2+M2) * (L3+M3+ONE) * (L3-M3)
NEWFAC = SQRT(A1)
!
!
DV = (L1+L2+L3+ONE)*(L2+L3-L1) - (L2-M2+ONE)*(L3+M3+ONE) &
- (L2+M2-ONE)*(L3-M3-ONE)
!
if ( LSTEP-2)  32, 32, 31
!
31 C1OLD = ABS(C1)
32 C1 = - DV / NEWFAC
!
if ( LSTEP > 2)   go to 60
!
!
!  If M2 = M2MIN + 1, the third term in the recursion equation vanishes,
!  hence
!
X = SRTINY * C1
THRCOF(2) = X
SUM1 = SUM1 + TINY * C1*C1
if ( LSTEP == NFIN)   go to 220
go to 30
!
!
60 C2 = - OLDFAC / NEWFAC
!
!  Recursion to the next 3j coefficient
X = C1 * THRCOF(LSTEP-1) + C2 * THRCOF(LSTEP-2)
THRCOF(LSTEP) = X
SUMFOR = SUM1
SUM1 = SUM1 + X*X
if ( LSTEP == NFIN)   go to 100
!
!  See if last unnormalized 3j coefficient exceeds SRHUGE
!
if ( ABS(X) < SRHUGE)   go to 80
!
!  This is reached if last 3j coefficient larger than SRHUGE,
!  so that the recursion series THRCOF(1), ... , THRCOF(LSTEP)
!  has to be rescaled to prevent overflow
!
!     MSCALE = MSCALE + 1
DO 70 I=1,LSTEP
if ( ABS(THRCOF(I)) < SRTINY)   THRCOF(I) = ZERO
70 THRCOF(I) = THRCOF(I) / SRHUGE
SUM1 = SUM1 / HUGE
SUMFOR = SUMFOR / HUGE
X = X / SRHUGE
!
!
!  As long as ABS(C1) is decreasing, the recursion proceeds towards
!  increasing 3j values and, hence, is numerically stable.  Once
!  an increase of ABS(C1) is detected, the recursion direction is
!  reversed.
!
80 if ( C1OLD-ABS(C1))   100, 100, 30
!
!
!  Keep three 3j coefficients around MMATCH for comparison later
!  with backward recursion values.
!
100 CONTINUE
!     MMATCH = M2 - 1
NSTEP2 = NFIN - LSTEP + 3
X1 = X
X2 = THRCOF(LSTEP-1)
X3 = THRCOF(LSTEP-2)
!
!  Starting backward recursion from M2MAX taking NSTEP2 steps, so
!  that forwards and backwards recursion overlap at the three points
!  M2 = MMATCH+1, MMATCH, MMATCH-1.
!
NFINP1 = NFIN + 1
NFINP2 = NFIN + 2
NFINP3 = NFIN + 3
THRCOF(NFIN) = SRTINY
SUM2 = TINY
!
!
!
M2 = M2MAX + TWO
LSTEP = 1
110 LSTEP = LSTEP + 1
M2 = M2 - ONE
M3 = - M1 - M2
OLDFAC = NEWFAC
A1S = (L2-M2+TWO) * (L2+M2-ONE) * (L3+M3+TWO) * (L3-M3-ONE)
NEWFAC = SQRT(A1S)
DV = (L1+L2+L3+ONE)*(L2+L3-L1) - (L2-M2+ONE)*(L3+M3+ONE) &
- (L2+M2-ONE)*(L3-M3-ONE)
C1 = - DV / NEWFAC
if ( LSTEP > 2)   go to 120
!
!  If M2 = M2MAX + 1 the third term in the recursion equation vanishes
!
Y = SRTINY * C1
THRCOF(NFIN-1) = Y
if ( LSTEP == NSTEP2)   go to 200
SUMBAC = SUM2
SUM2 = SUM2 + Y*Y
go to 110
!
120 C2 = - OLDFAC / NEWFAC
!
!  Recursion to the next 3j coefficient
!
Y = C1 * THRCOF(NFINP2-LSTEP) + C2 * THRCOF(NFINP3-LSTEP)
!
if ( LSTEP == NSTEP2)   go to 200
!
THRCOF(NFINP1-LSTEP) = Y
SUMBAC = SUM2
SUM2 = SUM2 + Y*Y
!
!
!  See if last 3j coefficient exceeds SRHUGE
!
if ( ABS(Y) < SRHUGE)   go to 110
!
!  This is reached if last 3j coefficient larger than SRHUGE,
!  so that the recursion series THRCOF(NFIN), ... , THRCOF(NFIN-LSTEP+1)
!  has to be rescaled to prevent overflow.
!
!     MSCALE = MSCALE + 1
DO 111 I=1,LSTEP
INDEX = NFIN - I + 1
if ( ABS(THRCOF(INDEX)) < SRTINY) &
THRCOF(INDEX) = ZERO
111 THRCOF(INDEX) = THRCOF(INDEX) / SRHUGE
SUM2 = SUM2 / HUGE
SUMBAC = SUMBAC / HUGE
!
go to 110
!
!
!
!  The forward recursion 3j coefficients X1, X2, X3 are to be matched
!  with the corresponding backward recursion values Y1, Y2, Y3.
!
200 Y3 = Y
Y2 = THRCOF(NFINP2-LSTEP)
Y1 = THRCOF(NFINP3-LSTEP)
!
!
!  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
!  with minimal error.
!
RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 )
NLIM = NFIN - NSTEP2 + 1
!
if ( ABS(RATIO) < ONE)   go to 211
!
DO 210 N=1,NLIM
210 THRCOF(N) = RATIO * THRCOF(N)
SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC
go to 230
!
211 NLIM = NLIM + 1
RATIO = ONE / RATIO
DO 212 N=NLIM,NFIN
212 THRCOF(N) = RATIO * THRCOF(N)
SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC
go to 230
!
220 SUMUNI = SUM1
!
!
!  Normalize 3j coefficients
!
230 CNORM = ONE / SQRT((L1+L1+ONE) * SUMUNI)
!
!  Sign convention for last 3j coefficient determines overall phase
!
SIGN1 = SIGN(ONE,THRCOF(NFIN))
SIGN2 = (-ONE) ** INT(ABS(L2-L3-M1)+EPS)
if ( SIGN1*SIGN2)  235,235,236
235 CNORM = - CNORM
!
236 if ( ABS(CNORM) < ONE)   go to 250
!
DO 240 N=1,NFIN
240 THRCOF(N) = CNORM * THRCOF(N)
return
!
250 THRESH = TINY / ABS(CNORM)
DO 251 N=1,NFIN
if ( ABS(THRCOF(N)) < THRESH)   THRCOF(N) = ZERO
251 THRCOF(N) = CNORM * THRCOF(N)
!
!
!
return
end





subroutine DRC3JJ (L2, L3, M2, M3, L1MIN, L1MAX, THRCOF, NDIM, &
IER)
!
!! DRC3JJ evaluates the 3J symbol f(L1) for all allowed values of L1.
!
!***PURPOSE  Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
!                                           (-M2-M3 M2 M3)
!            for all allowed values of L1, the other parameters
!            being held fixed.
!
!***LIBRARY   SLATEC
!***CATEGORY  C19
!***TYPE      DOUBLE PRECISION (RC3JJ-S, DRC3JJ-D)
!***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
!             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
!             WIGNER COEFFICIENTS
!***AUTHOR  Gordon, R. G., Harvard University
!           Schulten, K., Max Planck Institute
!***DESCRIPTION
!
! *Usage:
!
!        DOUBLE PRECISION L2, L3, M2, M3, L1MIN, L1MAX, THRCOF(NDIM)
!        INTEGER NDIM, IER
!
!        call DRC3JJ (L2, L3, M2, M3, L1MIN, L1MAX, THRCOF, NDIM, IER)
!
! *Arguments:
!
!     L2 :IN      Parameter in 3j symbol.
!
!     L3 :IN      Parameter in 3j symbol.
!
!     M2 :IN      Parameter in 3j symbol.
!
!     M3 :IN      Parameter in 3j symbol.
!
!     L1MIN :OUT  Smallest allowable L1 in 3j symbol.
!
!     L1MAX :OUT  Largest allowable L1 in 3j symbol.
!
!     THRCOF :OUT Set of 3j coefficients generated by evaluating the
!                 3j symbol for all allowed values of L1.  THRCOF(I)
!                 will contain f(L1MIN+I-1), I=1,2,...,L1MAX+L1MIN+1.
!
!     NDIM :IN    Declared length of THRCOF in calling program.
!
!     IER :OUT    Error flag.
!                 IER=0 No errors.
!                 IER=1 Either L2 < ABS(M2) or L3 < ABS(M3).
!                 IER=2 Either L2+ABS(M2) or L3+ABS(M3) non-integer.
!                 IER=3 L1MAX-L1MIN not an integer.
!                 IER=4 L1MAX less than L1MIN.
!                 IER=5 NDIM less than L1MAX-L1MIN+1.
!
! *Description:
!
!     Although conventionally the parameters of the vector addition
!  coefficients satisfy certain restrictions, such as being integers
!  or integers plus 1/2, the restrictions imposed on input to this
!  subroutine are somewhat weaker. See, for example, Section 27.9 of
!  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
!  The restrictions imposed by this subroutine are
!       1. L2  >=  ABS(M2) and L3  >=  ABS(M3);
!       2. L2+ABS(M2) and L3+ABS(M3) must be integers;
!       3. L1MAX-L1MIN must be a non-negative integer, where
!          L1MAX=L2+L3 and L1MIN=MAX(ABS(L2-L3),ABS(M2+M3)).
!  If the conventional restrictions are satisfied, then these
!  restrictions are met.
!
!     The user should be cautious in using input parameters that do
!  not satisfy the conventional restrictions. For example, the
!  the subroutine produces values of
!       f(L1) = ( L1  2.5  5.8)
!               (-0.31.5 -1.2)
!  for L1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j
!  symbol, set forth on page 1056 of Messiah, is satisfied.
!
!     The subroutine generates f(L1MIN), f(L1MIN+1), ..., f(L1MAX)
!  where L1MIN and L1MAX are defined above. The sequence f(L1) is
!  generated by a three-term recurrence algorithm with scaling to
!  control overflow. Both backward and forward recurrence are used to
!  maintain numerical stability. The two recurrence sequences are
!  matched at an interior point and are normalized from the unitary
!  property of 3j coefficients and Wigner's phase convention.
!
!    The algorithm is suited to applications in which large quantum
!  numbers arise, such as in molecular dynamics.
!
!***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
!                  of Mathematical Functions with Formulas, Graphs
!                  and Mathematical Tables, NBS Applied Mathematics
!                  Series 55, June 1964 and subsequent printings.
!               2. Messiah, Albert., Quantum Mechanics, Volume II,
!                  North-Holland Publishing Company, 1963.
!               3. Schulten, Klaus and Gordon, Roy G., Exact recursive
!                  evaluation of 3j and 6j coefficients for quantum-
!                  mechanical coupling of angular momenta, J Math
!                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
!               4. Schulten, Klaus and Gordon, Roy G., Semiclassical
!                  approximations to 3j  and 6j coefficients for
!                  quantum-mechanical coupling of angular momenta,
!                  J Math Phys, v 16, no. 10, October 1975,
!                  pp. 1971-1988.
!               5. Schulten, Klaus and Gordon, Roy G., Recursive
!                  evaluation of 3j and 6j coefficients, Computer
!                  Phys Comm, v 11, 1976, pp. 269-278.
!***ROUTINES CALLED  D1MACH, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   750101  DATE WRITTEN
!   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
!           HUGE and TINY revised to depend on D1MACH.
!   891229  Prologue description rewritten; other prologue sections
!           revised; LMATCH (location of match point for recurrences)
!           removed from argument list; argument IER changed to serve
!           only as an error flag (previously, in cases without error,
!           it returned the number of scalings); number of error codes
!           increased to provide more precise error information;
!           program comments revised; SLATEC error handler calls
!           introduced to enable printing of error messages to meet
!           SLATEC standards. These changes were done by D. W. Lozier,
!           M. A. McClain and J. M. Smith of the National Institute
!           of Standards and Technology, formerly NBS.
!   910415  Mixed type expressions eliminated; variable C1 initialized;
!           description of THRCOF expanded. These changes were done by
!           D. W. Lozier.
!***END PROLOGUE  DRC3JJ
!
INTEGER NDIM, IER
DOUBLE PRECISION L2, L3, M2, M3, L1MIN, L1MAX, THRCOF(NDIM)
!
INTEGER I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM, &
NSTEP2
DOUBLE PRECISION A1, A1S, A2, A2S, C1, C1OLD, C2, CNORM, D1MACH, &
DENOM, DV, EPS, HUGE, L1, M1, NEWFAC, OLDFAC, &
ONE, RATIO, SIGN1, SIGN2, SRHUGE, SRTINY, SUM1, &
SUM2, SUMBAC, SUMFOR, SUMUNI, THREE, THRESH, &
TINY, TWO, X, X1, X2, X3, Y, Y1, Y2, Y3, ZERO
!
DATA  ZERO,EPS,ONE,TWO,THREE /0.0D0,0.01D0,1.0D0,2.0D0,3.0D0/
!
!***FIRST EXECUTABLE STATEMENT  DRC3JJ
IER=0
!  HUGE is the square root of one twentieth of the largest floating
!  point number, approximately.
HUGE = SQRT(D1MACH(2)/20.0D0)
SRHUGE = SQRT(HUGE)
TINY = 1.0D0/HUGE
SRTINY = 1.0D0/SRHUGE
!
!     LMATCH = ZERO
M1 = - M2 - M3
!
!  Check error conditions 1 and 2.
if ( (L2-ABS(M2)+EPS < ZERO).OR. &
(L3-ABS(M3)+EPS < ZERO))THEN
IER=1
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JJ','L2-ABS(M2) or L3-ABS(M3) '// &
!    'less than zero.',IER,1)
return
ELSEIF((MOD(L2+ABS(M2)+EPS,ONE) >= EPS+EPS).OR. &
(MOD(L3+ABS(M3)+EPS,ONE) >= EPS+EPS))THEN
IER=2
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JJ','L2+ABS(M2) or L3+ABS(M3) '// &
!    'not integer.',IER,1)
return
end if
!
!
!
!  Limits for L1
!
L1MIN = MAX(ABS(L2-L3),ABS(M1))
L1MAX = L2 + L3
!
!  Check error condition 3.
if ( MOD(L1MAX-L1MIN+EPS,ONE) >= EPS+EPS)THEN
IER=3
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JJ','L1MAX-L1MIN not integer.',IER,1)
return
end if
if ( L1MIN < L1MAX-EPS)   go to 20
if ( L1MIN < L1MAX+EPS)   go to 10
!
!  Check error condition 4.
IER=4
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JJ','L1MIN greater than L1MAX.',IER,1)
return
!
!  This is reached in case that L1 can take only one value,
!  i.e. L1MIN = L1MAX
!
10 CONTINUE
!     LSCALE = 0
THRCOF(1) = (-ONE) ** INT(ABS(L2+M2-L3+M3)+EPS) / &
SQRT(L1MIN + L2 + L3 + ONE)
return
!
!  This is reached in case that L1 takes more than one value,
!  i.e. L1MIN < L1MAX.
!
20 CONTINUE
!     LSCALE = 0
NFIN = INT(L1MAX-L1MIN+ONE+EPS)
if ( NDIM-NFIN)  21, 23, 23
!
!  Check error condition 5.
21 IER = 5
print*, "Exited with ier = ", IER
! call XERMSG('SLATEC','DRC3JJ','Dimension of result array for '// &
!             '3j coefficients too small.',IER,1)
return
!
!
!  Starting forward recursion from L1MIN taking NSTEP1 steps
!
23 L1 = L1MIN
NEWFAC = 0.0D0
C1 = 0.0D0
THRCOF(1) = SRTINY
SUM1 = (L1+L1+ONE) * TINY
!
!
LSTEP = 1
30 LSTEP = LSTEP + 1
L1 = L1 + ONE
!
!
OLDFAC = NEWFAC
A1 = (L1+L2+L3+ONE) * (L1-L2+L3) * (L1+L2-L3) * (-L1+L2+L3+ONE)
A2 = (L1+M1) * (L1-M1)
NEWFAC = SQRT(A1*A2)
if ( L1 < ONE+EPS)   go to 40
!
!
DV = - L2*(L2+ONE) * M1 + L3*(L3+ONE) * M1 + L1*(L1-ONE) * (M3-M2)
DENOM = (L1-ONE) * NEWFAC
!
if ( LSTEP-2)  32, 32, 31
!
31 C1OLD = ABS(C1)
32 C1 = - (L1+L1-ONE) * DV / DENOM
go to 50
!
!  If L1 = 1, (L1-1) has to be factored out of DV, hence
!
40 C1 = - (L1+L1-ONE) * L1 * (M3-M2) / NEWFAC
!
50 if ( LSTEP > 2)   go to 60
!
!
!  If L1 = L1MIN + 1, the third term in the recursion equation vanishes,
!  hence
X = SRTINY * C1
THRCOF(2) = X
SUM1 = SUM1 + TINY * (L1+L1+ONE) * C1*C1
if ( LSTEP == NFIN)   go to 220
go to 30
!
!
60 C2 = - L1 * OLDFAC / DENOM
!
!  Recursion to the next 3j coefficient X
!
X = C1 * THRCOF(LSTEP-1) + C2 * THRCOF(LSTEP-2)
THRCOF(LSTEP) = X
SUMFOR = SUM1
SUM1 = SUM1 + (L1+L1+ONE) * X*X
if ( LSTEP == NFIN)   go to 100
!
!  See if last unnormalized 3j coefficient exceeds SRHUGE
!
if ( ABS(X) < SRHUGE)   go to 80
!
!  This is reached if last 3j coefficient larger than SRHUGE,
!  so that the recursion series THRCOF(1), ... , THRCOF(LSTEP)
!  has to be rescaled to prevent overflow
!
!     LSCALE = LSCALE + 1
DO 70 I=1,LSTEP
if ( ABS(THRCOF(I)) < SRTINY)   THRCOF(I) = ZERO
70 THRCOF(I) = THRCOF(I) / SRHUGE
SUM1 = SUM1 / HUGE
SUMFOR = SUMFOR / HUGE
X = X / SRHUGE
!
!  As long as ABS(C1) is decreasing, the recursion proceeds towards
!  increasing 3j values and, hence, is numerically stable.  Once
!  an increase of ABS(C1) is detected, the recursion direction is
!  reversed.
!
80 if ( C1OLD-ABS(C1))   100, 100, 30
!
!
!  Keep three 3j coefficients around LMATCH for comparison with
!  backward recursion.
!
100 CONTINUE
!     LMATCH = L1 - 1
X1 = X
X2 = THRCOF(LSTEP-1)
X3 = THRCOF(LSTEP-2)
NSTEP2 = NFIN - LSTEP + 3
!
!
!
!
!  Starting backward recursion from L1MAX taking NSTEP2 steps, so
!  that forward and backward recursion overlap at three points
!  L1 = LMATCH+1, LMATCH, LMATCH-1.
!
NFINP1 = NFIN + 1
NFINP2 = NFIN + 2
NFINP3 = NFIN + 3
L1 = L1MAX
THRCOF(NFIN) = SRTINY
SUM2 = TINY * (L1+L1+ONE)
!
L1 = L1 + TWO
LSTEP = 1
110 LSTEP = LSTEP + 1
L1 = L1 - ONE
!
OLDFAC = NEWFAC
A1S = (L1+L2+L3)*(L1-L2+L3-ONE)*(L1+L2-L3-ONE)*(-L1+L2+L3+TWO)
A2S = (L1+M1-ONE) * (L1-M1-ONE)
NEWFAC = SQRT(A1S*A2S)
!
DV = - L2*(L2+ONE) * M1 + L3*(L3+ONE) * M1 + L1*(L1-ONE) * (M3-M2)
!
DENOM = L1 * NEWFAC
C1 = - (L1+L1-ONE) * DV / DENOM
if ( LSTEP > 2)   go to 120
!
!  If L1 = L1MAX + 1, the third term in the recursion formula vanishes
!
Y = SRTINY * C1
THRCOF(NFIN-1) = Y
SUMBAC = SUM2
SUM2 = SUM2 + TINY * (L1+L1-THREE) * C1*C1
!
go to 110
!
!
120 C2 = - (L1 - ONE) * OLDFAC / DENOM
!
!  Recursion to the next 3j coefficient Y
!
Y = C1 * THRCOF(NFINP2-LSTEP) + C2 * THRCOF(NFINP3-LSTEP)
!
if ( LSTEP == NSTEP2)   go to 200
!
THRCOF(NFINP1-LSTEP) = Y
SUMBAC = SUM2
SUM2 = SUM2 + (L1+L1-THREE) * Y*Y
!
!  See if last unnormalized 3j coefficient exceeds SRHUGE
!
if ( ABS(Y) < SRHUGE)   go to 110
!
!  This is reached if last 3j coefficient larger than SRHUGE,
!  so that the recursion series THRCOF(NFIN), ... ,THRCOF(NFIN-LSTEP+1)
!  has to be rescaled to prevent overflow
!
!     LSCALE = LSCALE + 1
DO 130 I=1,LSTEP
INDEX = NFIN - I + 1
if ( ABS(THRCOF(INDEX)) < SRTINY)   THRCOF(INDEX) = ZERO
130 THRCOF(INDEX) = THRCOF(INDEX) / SRHUGE
SUM2 = SUM2 / HUGE
SUMBAC = SUMBAC / HUGE
!
!
go to 110
!
!
!  The forward recursion 3j coefficients X1, X2, X3 are to be matched
!  with the corresponding backward recursion values Y1, Y2, Y3.
!
200 Y3 = Y
Y2 = THRCOF(NFINP2-LSTEP)
Y1 = THRCOF(NFINP3-LSTEP)
!
!
!  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
!  with minimal error.
!
RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 )
NLIM = NFIN - NSTEP2 + 1
!
if ( ABS(RATIO) < ONE)   go to 211
!
DO 210 N=1,NLIM
210 THRCOF(N) = RATIO * THRCOF(N)
SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC
go to 230
!
211 NLIM = NLIM + 1
RATIO = ONE / RATIO
DO 212 N=NLIM,NFIN
212 THRCOF(N) = RATIO * THRCOF(N)
SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC
go to 230
!
220 SUMUNI = SUM1
!
!
!  Normalize 3j coefficients
!
230 CNORM = ONE / SQRT(SUMUNI)
!
!  Sign convention for last 3j coefficient determines overall phase
!
SIGN1 = SIGN(ONE,THRCOF(NFIN))
SIGN2 = (-ONE) ** INT(ABS(L2+M2-L3+M3)+EPS)
if ( SIGN1*SIGN2) 235,235,236
235 CNORM = - CNORM
!
236 if ( ABS(CNORM) < ONE)   go to 250
!
DO 240 N=1,NFIN
240 THRCOF(N) = CNORM * THRCOF(N)
return
!
250 THRESH = TINY / ABS(CNORM)
DO 251 N=1,NFIN
if ( ABS(THRCOF(N)) < THRESH)   THRCOF(N) = ZERO
251 THRCOF(N) = CNORM * THRCOF(N)
!
return
end





subroutine DRC6J (L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF, NDIM, &
IER)
!
!! DRC6J evaluates the 6j symbol h(L1) for all allowed values of L1.
!
!***PURPOSE  Evaluate the 6j symbol h(L1) = {L1 L2 L3}
!                                           {L4 L5 L6}
!            for all allowed values of L1, the other parameters
!            being held fixed.
!
!***LIBRARY   SLATEC
!***CATEGORY  C19
!***TYPE      DOUBLE PRECISION (RC6J-S, DRC6J-D)
!***KEYWORDS  6J COEFFICIENTS, 6J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
!             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
!             WIGNER COEFFICIENTS
!***AUTHOR  Gordon, R. G., Harvard University
!           Schulten, K., Max Planck Institute
!***DESCRIPTION
!
! *Usage:
!
!        DOUBLE PRECISION L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF(NDIM)
!        INTEGER NDIM, IER
!
!        call DRC6J(L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF, NDIM, IER)
!
! *Arguments:
!
!     L2 :IN      Parameter in 6j symbol.
!
!     L3 :IN      Parameter in 6j symbol.
!
!     L4 :IN      Parameter in 6j symbol.
!
!     L5 :IN      Parameter in 6j symbol.
!
!     L6 :IN      Parameter in 6j symbol.
!
!     L1MIN :OUT  Smallest allowable L1 in 6j symbol.
!
!     L1MAX :OUT  Largest allowable L1 in 6j symbol.
!
!     SIXCOF :OUT Set of 6j coefficients generated by evaluating the
!                 6j symbol for all allowed values of L1.  SIXCOF(I)
!                 will contain h(L1MIN+I-1), I=1,2,...,L1MAX-L1MIN+1.
!
!     NDIM :IN    Declared length of SIXCOF in calling program.
!
!     IER :OUT    Error flag.
!                 IER=0 No errors.
!                 IER=1 L2+L3+L5+L6 or L4+L2+L6 not an integer.
!                 IER=2 L4, L2, L6 triangular condition not satisfied.
!                 IER=3 L4, L5, L3 triangular condition not satisfied.
!                 IER=4 L1MAX-L1MIN not an integer.
!                 IER=5 L1MAX less than L1MIN.
!                 IER=6 NDIM less than L1MAX-L1MIN+1.
!
! *Description:
!
!     The definition and properties of 6j symbols can be found, for
!  example, in Appendix C of Volume II of A. Messiah. Although the
!  parameters of the vector addition coefficients satisfy certain
!  conventional restrictions, the restriction that they be non-negative
!  integers or non-negative integers plus 1/2 is not imposed on input
!  to this subroutine. The restrictions imposed are
!       1. L2+L3+L5+L6 and L2+L4+L6 must be integers;
!       2. ABS(L2-L4) <= L6 <= L2+L4 must be satisfied;
!       3. ABS(L4-L5) <= L3 <= L4+L5 must be satisfied;
!       4. L1MAX-L1MIN must be a non-negative integer, where
!          L1MAX=MIN(L2+L3,L5+L6) and L1MIN=MAX(ABS(L2-L3),ABS(L5-L6)).
!  If all the conventional restrictions are satisfied, then these
!  restrictions are met. Conversely, if input to this subroutine meets
!  all of these restrictions and the conventional restriction stated
!  above, then all the conventional restrictions are satisfied.
!
!     The user should be cautious in using input parameters that do
!  not satisfy the conventional restrictions. For example, the
!  the subroutine produces values of
!       h(L1) = { L12/3  1 }
!               {2/32/32/3}
!  for L1=1/3 and 4/3 but none of the symmetry properties of the 6j
!  symbol, set forth on pages 1063 and 1064 of Messiah, is satisfied.
!
!     The subroutine generates h(L1MIN), h(L1MIN+1), ..., h(L1MAX)
!  where L1MIN and L1MAX are defined above. The sequence h(L1) is
!  generated by a three-term recurrence algorithm with scaling to
!  control overflow. Both backward and forward recurrence are used to
!  maintain numerical stability. The two recurrence sequences are
!  matched at an interior point and are normalized from the unitary
!  property of 6j coefficients and Wigner's phase convention.
!
!    The algorithm is suited to applications in which large quantum
!  numbers arise, such as in molecular dynamics.
!
!***REFERENCES  1. Messiah, Albert., Quantum Mechanics, Volume II,
!                  North-Holland Publishing Company, 1963.
!               2. Schulten, Klaus and Gordon, Roy G., Exact recursive
!                  evaluation of 3j and 6j coefficients for quantum-
!                  mechanical coupling of angular momenta, J Math
!                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
!               3. Schulten, Klaus and Gordon, Roy G., Semiclassical
!                  approximations to 3j and 6j coefficients for
!                  quantum-mechanical coupling of angular momenta,
!                  J Math Phys, v 16, no. 10, October 1975,
!                  pp. 1971-1988.
!               4. Schulten, Klaus and Gordon, Roy G., Recursive
!                  evaluation of 3j and 6j coefficients, Computer
!                  Phys Comm, v 11, 1976, pp. 269-278.
!***ROUTINES CALLED  D1MACH, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   750101  DATE WRITTEN
!   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
!           HUGE and TINY revised to depend on D1MACH.
!   891229  Prologue description rewritten; other prologue sections
!           revised; LMATCH (location of match point for recurrences)
!           removed from argument list; argument IER changed to serve
!           only as an error flag (previously, in cases without error,
!           it returned the number of scalings); number of error codes
!           increased to provide more precise error information;
!           program comments revised; SLATEC error handler calls
!           introduced to enable printing of error messages to meet
!           SLATEC standards. These changes were done by D. W. Lozier,
!           M. A. McClain and J. M. Smith of the National Institute
!           of Standards and Technology, formerly NBS.
!   910415  Mixed type expressions eliminated; variable C1 initialized;
!           description of SIXCOF expanded. These changes were done by
!           D. W. Lozier.
!***END PROLOGUE  DRC6J
!
INTEGER NDIM, IER
DOUBLE PRECISION L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF(NDIM)
!
INTEGER I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM, &
NSTEP2
DOUBLE PRECISION A1, A1S, A2, A2S, C1, C1OLD, C2, CNORM, D1MACH, &
DENOM, DV, EPS, HUGE, L1, NEWFAC, OLDFAC, ONE, &
RATIO, SIGN1, SIGN2, SRHUGE, SRTINY, SUM1, SUM2, &
SUMBAC, SUMFOR, SUMUNI, THREE, THRESH, TINY, TWO, &
X, X1, X2, X3, Y, Y1, Y2, Y3, ZERO
!
DATA  ZERO,EPS,ONE,TWO,THREE /0.0D0,0.01D0,1.0D0,2.0D0,3.0D0/
!
!***FIRST EXECUTABLE STATEMENT  DRC6J
IER=0
!  HUGE is the square root of one twentieth of the largest floating
!  point number, approximately.
HUGE = SQRT(D1MACH(2)/20.0D0)
SRHUGE = SQRT(HUGE)
TINY = 1.0D0/HUGE
SRTINY = 1.0D0/SRHUGE
!
!     LMATCH = ZERO
!
!  Check error conditions 1, 2, and 3.
if ( (MOD(L2+L3+L5+L6+EPS,ONE) >= EPS+EPS).OR. &
(MOD(L4+L2+L6+EPS,ONE) >= EPS+EPS))THEN
IER=1
! call XERMSG('SLATEC','DRC6J','L2+L3+L5+L6 or L4+L2+L6 not '// &
!    'integer.',IER,1)
return
ELSEIF((L4+L2-L6 < ZERO).OR.(L4-L2+L6 < ZERO).OR. &
(-L4+L2+L6 < ZERO))THEN
IER=2
! call XERMSG('SLATEC','DRC6J','L4, L2, L6 triangular '// &
!    'condition not satisfied.',IER,1)
return
ELSEIF((L4-L5+L3 < ZERO).OR.(L4+L5-L3 < ZERO).OR. &
(-L4+L5+L3 < ZERO))THEN
IER=3
! call XERMSG('SLATEC','DRC6J','L4, L5, L3 triangular '// &
!    'condition not satisfied.',IER,1)
return
end if
!
!  Limits for L1
!
L1MIN = MAX(ABS(L2-L3),ABS(L5-L6))
L1MAX = MIN(L2+L3,L5+L6)
!
!  Check error condition 4.
if ( MOD(L1MAX-L1MIN+EPS,ONE) >= EPS+EPS)THEN
IER=4
! call XERMSG('SLATEC','DRC6J','L1MAX-L1MIN not integer.',IER,1)
return
end if
if ( L1MIN < L1MAX-EPS)   go to 20
if ( L1MIN < L1MAX+EPS)   go to 10
!
!  Check error condition 5.
IER=5
! call XERMSG('SLATEC','DRC6J','L1MIN greater than L1MAX.',IER,1)
return
!
!
!  This is reached in case that L1 can take only one value
!
10 CONTINUE
!     LSCALE = 0
SIXCOF(1) = (-ONE) ** INT(L2+L3+L5+L6+EPS) / &
SQRT((L1MIN+L1MIN+ONE)*(L4+L4+ONE))
return
!
!
!  This is reached in case that L1 can take more than one value.
!
20 CONTINUE
!     LSCALE = 0
NFIN = INT(L1MAX-L1MIN+ONE+EPS)
if ( NDIM-NFIN)   21, 23, 23
!
!  Check error condition 6.
21 IER = 6
! call XERMSG('SLATEC','DRC6J','Dimension of result array for 6j '// &
!             'coefficients too small.',IER,1)
return
!
!
!  Start of forward recursion
!
23 L1 = L1MIN
NEWFAC = 0.0D0
C1 = 0.0D0
SIXCOF(1) = SRTINY
SUM1 = (L1+L1+ONE) * TINY
!
LSTEP = 1
30 LSTEP = LSTEP + 1
L1 = L1 + ONE
!
OLDFAC = NEWFAC
A1 = (L1+L2+L3+ONE) * (L1-L2+L3) * (L1+L2-L3) * (-L1+L2+L3+ONE)
A2 = (L1+L5+L6+ONE) * (L1-L5+L6) * (L1+L5-L6) * (-L1+L5+L6+ONE)
NEWFAC = SQRT(A1*A2)
!
if ( L1 < ONE+EPS)   go to 40
!
DV = TWO * ( L2*(L2+ONE)*L5*(L5+ONE) + L3*(L3+ONE)*L6*(L6+ONE) &
- L1*(L1-ONE)*L4*(L4+ONE) ) &
- (L2*(L2+ONE) + L3*(L3+ONE) - L1*(L1-ONE)) &
* (L5*(L5+ONE) + L6*(L6+ONE) - L1*(L1-ONE))
!
DENOM = (L1-ONE) * NEWFAC
!
if ( LSTEP-2)  32, 32, 31
!
31 C1OLD = ABS(C1)
32 C1 = - (L1+L1-ONE) * DV / DENOM
go to 50
!
!  If L1 = 1, (L1 - 1) has to be factored out of DV, hence
!
40 C1 = - TWO * ( L2*(L2+ONE) + L5*(L5+ONE) - L4*(L4+ONE) ) &
/ NEWFAC
!
50 if ( LSTEP > 2)   go to 60
!
!  If L1 = L1MIN + 1, the third term in recursion equation vanishes
!
X = SRTINY * C1
SIXCOF(2) = X
SUM1 = SUM1 + TINY * (L1+L1+ONE) * C1 * C1
!
if ( LSTEP == NFIN)   go to 220
go to 30
!
!
60 C2 = - L1 * OLDFAC / DENOM
!
!  Recursion to the next 6j coefficient X
!
X = C1 * SIXCOF(LSTEP-1) + C2 * SIXCOF(LSTEP-2)
SIXCOF(LSTEP) = X
!
SUMFOR = SUM1
SUM1 = SUM1 + (L1+L1+ONE) * X * X
if ( LSTEP == NFIN)   go to 100
!
!  See if last unnormalized 6j coefficient exceeds SRHUGE
!
if ( ABS(X) < SRHUGE)   go to 80
!
!  This is reached if last 6j coefficient larger than SRHUGE,
!  so that the recursion series SIXCOF(1), ... ,SIXCOF(LSTEP)
!  has to be rescaled to prevent overflow
!
!     LSCALE = LSCALE + 1
DO 70 I=1,LSTEP
if ( ABS(SIXCOF(I)) < SRTINY)   SIXCOF(I) = ZERO
70 SIXCOF(I) = SIXCOF(I) / SRHUGE
SUM1 = SUM1 / HUGE
SUMFOR = SUMFOR / HUGE
X = X / SRHUGE
!
!
!  As long as the coefficient ABS(C1) is decreasing, the recursion
!  proceeds towards increasing 6j values and, hence, is numerically
!  stable.  Once an increase of ABS(C1) is detected, the recursion
!  direction is reversed.
!
80 if ( C1OLD-ABS(C1))   100, 100, 30
!
!
!  Keep three 6j coefficients around LMATCH for comparison later
!  with backward recursion.
!
100 CONTINUE
!     LMATCH = L1 - 1
X1 = X
X2 = SIXCOF(LSTEP-1)
X3 = SIXCOF(LSTEP-2)
!
!
!
!  Starting backward recursion from L1MAX taking NSTEP2 steps, so
!  that forward and backward recursion overlap at the three points
!  L1 = LMATCH+1, LMATCH, LMATCH-1.
!
NFINP1 = NFIN + 1
NFINP2 = NFIN + 2
NFINP3 = NFIN + 3
NSTEP2 = NFIN - LSTEP + 3
L1 = L1MAX
!
SIXCOF(NFIN) = SRTINY
SUM2 = (L1+L1+ONE) * TINY
!
!
L1 = L1 + TWO
LSTEP = 1
110 LSTEP = LSTEP + 1
L1 = L1 - ONE
!
OLDFAC = NEWFAC
A1S = (L1+L2+L3)*(L1-L2+L3-ONE)*(L1+L2-L3-ONE)*(-L1+L2+L3+TWO)
A2S = (L1+L5+L6)*(L1-L5+L6-ONE)*(L1+L5-L6-ONE)*(-L1+L5+L6+TWO)
NEWFAC = SQRT(A1S*A2S)
!
DV = TWO * ( L2*(L2+ONE)*L5*(L5+ONE) + L3*(L3+ONE)*L6*(L6+ONE) &
- L1*(L1-ONE)*L4*(L4+ONE) ) &
- (L2*(L2+ONE) + L3*(L3+ONE) - L1*(L1-ONE)) &
* (L5*(L5+ONE) + L6*(L6+ONE) - L1*(L1-ONE))
!
DENOM = L1 * NEWFAC
C1 = - (L1+L1-ONE) * DV / DENOM
if ( LSTEP > 2)   go to 120
!
!  If L1 = L1MAX + 1 the third term in the recursion equation vanishes
!
Y = SRTINY * C1
SIXCOF(NFIN-1) = Y
if ( LSTEP == NSTEP2)   go to 200
SUMBAC = SUM2
SUM2 = SUM2 + (L1+L1-THREE) * C1 * C1 * TINY
go to 110
!
!
120 C2 = - (L1-ONE) * OLDFAC / DENOM
!
!  Recursion to the next 6j coefficient Y
!
Y = C1 * SIXCOF(NFINP2-LSTEP) + C2 * SIXCOF(NFINP3-LSTEP)
if ( LSTEP == NSTEP2)   go to 200
SIXCOF(NFINP1-LSTEP) = Y
SUMBAC = SUM2
SUM2 = SUM2 + (L1+L1-THREE) * Y * Y
!
!  See if last unnormalized 6j coefficient exceeds SRHUGE
!
if ( ABS(Y) < SRHUGE)   go to 110
!
!  This is reached if last 6j coefficient larger than SRHUGE,
!  so that the recursion series SIXCOF(NFIN), ... ,SIXCOF(NFIN-LSTEP+1)
!  has to be rescaled to prevent overflow
!
!     LSCALE = LSCALE + 1
DO 130 I=1,LSTEP
INDEX = NFIN-I+1
if ( ABS(SIXCOF(INDEX)) < SRTINY)   SIXCOF(INDEX) = ZERO
130 SIXCOF(INDEX) = SIXCOF(INDEX) / SRHUGE
SUMBAC = SUMBAC / HUGE
SUM2 = SUM2 / HUGE
!
go to 110
!
!
!  The forward recursion 6j coefficients X1, X2, X3 are to be matched
!  with the corresponding backward recursion values Y1, Y2, Y3.
!
200 Y3 = Y
Y2 = SIXCOF(NFINP2-LSTEP)
Y1 = SIXCOF(NFINP3-LSTEP)
!
!
!  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
!  with minimal error.
!
RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 )
NLIM = NFIN - NSTEP2 + 1
!
if ( ABS(RATIO) < ONE)   go to 211
!
DO 210 N=1,NLIM
210 SIXCOF(N) = RATIO * SIXCOF(N)
SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC
go to 230
!
211 NLIM = NLIM + 1
RATIO = ONE / RATIO
DO 212 N=NLIM,NFIN
212 SIXCOF(N) = RATIO * SIXCOF(N)
SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC
go to 230
!
220 SUMUNI = SUM1
!
!
!  Normalize 6j coefficients
!
230 CNORM = ONE / SQRT((L4+L4+ONE)*SUMUNI)
!
!  Sign convention for last 6j coefficient determines overall phase
!
SIGN1 = SIGN(ONE,SIXCOF(NFIN))
SIGN2 = (-ONE) ** INT(L2+L3+L5+L6+EPS)
if ( SIGN1*SIGN2) 235,235,236
235 CNORM = - CNORM
!
236 if ( ABS(CNORM) < ONE)   go to 250
!
DO 240 N=1,NFIN
240 SIXCOF(N) = CNORM * SIXCOF(N)
return
!
250 THRESH = TINY / ABS(CNORM)
DO 251 N=1,NFIN
if ( ABS(SIXCOF(N)) < THRESH)   SIXCOF(N) = ZERO
251 SIXCOF(N) = CNORM * SIXCOF(N)
!
return
end


! *** MY MODIFICATIONS
! The SLATEC library has a complex error-handling system that relies on
! the XERMSG, XERPRN and other functions.  In order to make pieces of SLATEC
! easier to include in my C code (that has its own error management), I
! overwrite XERMSG so that it only only prints a simple error message.

subroutine XERMSG (LIBRAR, SUBROU, MESSG, NERR, LEVEL)

CHARACTER*(*) LIBRAR, SUBROU, MESSG

PRINT *, "ERROR IN SLATEC '", SUBROU, "': ", MESSG

end


!!!  UPDATED D1MACH FUNCTION TAKEN FROM
!!!  http://www.nsc.liu.se/~boein/ifip/kyoto/workshop-info/proceedings/einarsson/f90/d1mach.f90
!!!  NB: DIFFERENT FROM THE VERSION IN BURKHARDT PORT!
!DECK D1MACH
DOUBLE PRECISION FUNCTION D1MACH (I)
IMPLICIT NONE
INTEGER :: I
DOUBLE PRECISION :: B, X
!***BEGIN PROLOGUE  D1MACH
!***PURPOSE  Return floating point machine dependent constants.
!***LIBRARY   SLATEC
!***CATEGORY  R1
!***TYPE      SINGLE PRECISION (D1MACH-S, D1MACH-D)
!***KEYWORDS  MACHINE CONSTANTS
!***AUTHOR  Fox, P. A., (Bell Labs)
!           Hall, A. D., (Bell Labs)
!           Schryer, N. L., (Bell Labs)
!***DESCRIPTION
!
!   D1MACH can be used to obtain machine-dependent parameters for the
!   local machine environment.  It is a function subprogram with one
!   (input) argument, and can be referenced as follows:
!
!        A = D1MACH(I)
!
!   where I=1,...,5.  The (output) value of A above is determined by
!   the (input) value of I.  The results for various values of I are
!   discussed below.
!
!   D1MACH(1) = B**(EMIN-1), the smallest positive magnitude.
!   D1MACH(2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
!   D1MACH(3) = B**(-T), the smallest relative spacing.
!   D1MACH(4) = B**(1-T), the largest relative spacing.
!   D1MACH(5) = LOG10(B)
!
!   Assume single precision numbers are represented in the T-digit,
!   base-B form
!
!              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
!
!   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and
!   EMIN .LE. E .LE. EMAX.
!
!   The values of B, T, EMIN and EMAX are provided in I1MACH as
!   follows:
!   I1MACH(10) = B, the base.
!   I1MACH(11) = T, the number of base-B digits.
!   I1MACH(12) = EMIN, the smallest exponent E.
!   I1MACH(13) = EMAX, the largest exponent E.
!
!
!***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
!                 a portable library, ACM Transactions on Mathematical
!                 Software 4, 2 (June 1978), pp. 177-188.
!***ROUTINES CALLED  XERMSG
!***REVISION HISTORY  (YYMMDD)
!   790101  DATE WRITTEN
!   960329  Modified for Fortran 90 (BE after suggestions by EHG)
!***END PROLOGUE  D1MACH
!
X = 1.0D0
B = RADIX(X)
SELECT CASE (I)
CASE (1)
D1MACH = B**(MINEXPONENT(X)-1) ! the smallest positive magnitude.
CASE (2)
D1MACH = HUGE(X)               ! the largest magnitude.
CASE (3)
D1MACH = B**(-DIGITS(X))       ! the smallest relative spacing.
CASE (4)
D1MACH = B**(1-DIGITS(X))      ! the largest relative spacing.
CASE (5)
D1MACH = LOG10(B)
CASE DEFAULT
WRITE (*, FMT = 9000)
9000     FORMAT ('1ERROR    1 IN D1MACH - I OUT OF BOUNDS')
STOP
END SELECT
RETURN
END


! Test function.  Used to check that arrays are passed correctly between
! C and Fortran.
subroutine set_array_to_one(pntr, ndim)

INTEGER ndim, i
DOUBLE PRECISION pntr(ndim)

DO i=1,ndim
pntr(i) = 1.
ENDDO

end subroutine



!!!  UPDATED R1MACH FUNCTION TAKEN FROM
!!!  http://www.nsc.liu.se/~boein/ifip/kyoto/workshop-info/proceedings/einarsson/f90/r1mach.f90
!!!  NB: DIFFERENT FROM THE VERSION IN BURKHARDT PORT!

!DECK R1MACH
REAL FUNCTION R1MACH (I)
IMPLICIT NONE
INTEGER :: I
REAL :: B, X
!***BEGIN PROLOGUE  R1MACH
!***PURPOSE  Return floating point machine dependent constants.
!***LIBRARY   SLATEC
!***CATEGORY  R1
!***TYPE      SINGLE PRECISION (R1MACH-S, D1MACH-D)
!***KEYWORDS  MACHINE CONSTANTS
!***AUTHOR  Fox, P. A., (Bell Labs)
!           Hall, A. D., (Bell Labs)
!           Schryer, N. L., (Bell Labs)
!***DESCRIPTION
!
!   R1MACH can be used to obtain machine-dependent parameters for the
!   local machine environment.  It is a function subprogram with one
!   (input) argument, and can be referenced as follows:
!
!        A = R1MACH(I)
!
!   where I=1,...,5.  The (output) value of A above is determined by
!   the (input) value of I.  The results for various values of I are
!   discussed below.
!
!   R1MACH(1) = B**(EMIN-1), the smallest positive magnitude.
!   R1MACH(2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
!   R1MACH(3) = B**(-T), the smallest relative spacing.
!   R1MACH(4) = B**(1-T), the largest relative spacing.
!   R1MACH(5) = LOG10(B)
!
!   Assume single precision numbers are represented in the T-digit,
!   base-B form
!
!              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
!
!   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and
!   EMIN .LE. E .LE. EMAX.
!
!   The values of B, T, EMIN and EMAX are provided in I1MACH as
!   follows:
!   I1MACH(10) = B, the base.
!   I1MACH(11) = T, the number of base-B digits.
!   I1MACH(12) = EMIN, the smallest exponent E.
!   I1MACH(13) = EMAX, the largest exponent E.
!
!
!***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
!                 a portable library, ACM Transactions on Mathematical
!                 Software 4, 2 (June 1978), pp. 177-188.
!***ROUTINES CALLED  XERMSG
!***REVISION HISTORY  (YYMMDD)
!   790101  DATE WRITTEN
!   960329  Modified for Fortran 90 (BE after suggestions by EG)
!***END PROLOGUE  R1MACH
!
X = 1.0
B = RADIX(X)
SELECT CASE (I)
CASE (1)
R1MACH = B**(MINEXPONENT(X)-1) ! the smallest positive magnitude.
CASE (2)
R1MACH = HUGE(X)               ! the largest magnitude.
CASE (3)
R1MACH = B**(-DIGITS(X))       ! the smallest relative spacing.
CASE (4)
R1MACH = B**(1-DIGITS(X))      ! the largest relative spacing.
CASE (5)
R1MACH = LOG10(B)
CASE DEFAULT
WRITE (*, FMT = 9000)
9000     FORMAT ('1ERROR    1 IN R1MACH - I OUT OF BOUNDS')
STOP
END SELECT
RETURN
END
